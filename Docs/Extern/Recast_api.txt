// This file contains the detail API documentation for elements defined in the Recast.h.
//このファイルには、Recast.hで定義された要素の詳細なAPIドキュメントが含まれています。

/**

@defgroup recast Recast

Members in this module are used to create mesh data that is then used to create Detour navigation meshes.
このモジュールのメンバーは、メッシュデータを作成するために使用され、その後、迂回ナビゲーションメッシュを作成するために使用されます。

The are a large number of possible ways to building navigation mesh data.
ナビゲーションメッシュデータを作成する方法は多数あります。

One of the simple piplines is as follows:
単純なパイプラインの1つは次のとおりです。

-----------------------------------------------------------------------------------------------------------------------

- Prepare the input triangle mesh.
入力三角形メッシュを準備します。

- Build a #rcHeightfield.
rcHeightfieldを作成します。

- Build a #rcCompactHeightfield.
rcCompactHeightfieldを作成します。

- Build a #rcContourSet.
rcContourSetを作成します。

- Build a #rcPolyMesh.
rcPolyMeshをビルドします。

- Build a #rcPolyMeshDetail.
rcPolyMeshDetailを作成します。

- Use the rcPolyMesh and rcPolyMeshDetail to build a Detour navigation mesh tile.
rcPolyMeshおよびrcPolyMeshDetailを使用して、迂回ナビゲーションメッシュタイルを作成します。

-----------------------------------------------------------------------------------------------------------------------

The general life-cycle of the main classes is as follows:
主なクラスの一般的なライフサイクルは次のとおりです。

- Allocate the object using the Recast allocator. (E.g. #rcAllocHeightfield)
Recastアロケータを使用してオブジェクトを割り当てます。 （例：rcAllocHeightfield）

- Initialize or build the object. (E.g. #rcCreateHeightfield)
オブジェクトを初期化または構築します。 （例：rcCreateHeightfield）

- Update the object as needed. (E.g. #rcRasterizeTriangles)
必要に応じてオブジェクトを更新します。 （例：rcRasterizeTriangles）

- Use the object as part of the pipeline.
オブジェクトをパイプラインの一部として使用します。

- Free the object using the Recast allocator. (E.g. #rcFreeHeightField)
Recastアロケータを使用してオブジェクトを解放します。 （例：rcFreeHeightField）

@note This is a summary list of members.  Use the index or search feature to find minor members.
これはメンバーの要約リストです。インデックスまたは検索機能を使用して、マイナーメンバーを見つけます。

-----------------------------------------------------------------------------------------------------------------------

@struct rcConfig
@par

The is a convenience structure that represents an aggregation of parameters used at different stages in the Recast build process. 
Some values are derived during the build process. Not all parametersare used for all build processes.
これは、リキャストビルドプロセスのさまざまな段階で使用されるパラメーターの集約を表す便利な構造です。
一部の値は、ビルドプロセス中に取得されます。すべてのパラメーターがすべてのビルドプロセスに使用されるわけではありません。

Units are usually in voxels (vx) or world units (wu).  The units for voxels, grid size, and cell size are all based on the values of #cs and #ch.
単位は通常、ボクセル（vx）またはワールド単位（wu）です。
ボクセル、グリッドサイズ、セルサイズの単位は、すべて#csと#chの値に基づいています。

In this documentation, the term 'field' refers to heightfield and contour data structures that define spacial information using an integer grid.
このドキュメントでは、「フィールド」という用語は、整数グリッドを使用して空間情報を定義するハイトフィールドおよびコンターデータ構造を指します。

The upper and lower limits for the various parameters often depend on the platform's floating point accuraccy as well as interdependencies between the values of multiple parameters. 
See the individual parameter documentation for details.
多くの場合、さまざまなパラメーターの上限と下限は、プラットフォームの浮動小数点の精度と、複数のパラメーターの値間の相互依存性に依存します。詳細については、個々のパラメーターのドキュメントを参照してください。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::borderSize
@par

This value represents the the closest the walkable area of the heightfield 
should come to the xz-plane AABB of the field. 
It does not have any impact on the borders around internal obstructions.
この値は、heightfieldの歩行可能領域がフィールドのxz平面AABBに最も近くなることを表します。
内部の障害物の周囲の境界には影響を与えません。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::tileSize
@par

This field is only used when building multi-tile meshes.
このフィールドは、マルチタイルメッシュを構築するときにのみ使用されます。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::cs
@par

@p cs and #ch define voxel/grid/cell size.  So their values have significant 
side effects on all parameters defined in voxel units.
csと#chはボクセル/グリッド/セルサイズを定義します。
したがって、それらの値は、ボクセル単位で定義されたすべてのパラメーターに重大な副作用があります。

The minimum value for this parameter depends on the platform's floating point 
accuracy, with the practical minimum usually around 0.05.
このパラメーターの最小値はプラットフォームの浮動小数点の精度によって異なりますが、実際の最小値は通常約0.05です。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::ch
@par

#cs and @p ch define voxel/grid/cell size.  So their values have significant 
side effects on all parameters defined in voxel units.
#csと@p chはボクセル/グリッド/セルサイズを定義します。
したがって、それらの値は、ボクセル単位で定義されたすべてのパラメーターに重大な副作用があります。

The minimum value for this parameter depends on the platform's floating point 
accuracy, with the practical minimum usually around 0.05.
このパラメーターの最小値はプラットフォームの浮動小数点の精度によって異なりますが、実際の最小値は通常約0.05です。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::walkableSlopeAngle
@par

The practical upper limit for this parameter is usually around 85 degrees.
このパラメータの実用的な上限は通常、約85度です。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::walkableHeight
@par

Permits detection of overhangs in the source geometry that make the geometry
below un-walkable. The value is usually set to the maximum agent height.
ソースジオメトリのオーバーハングを検出して、その下のジオメトリを歩行不可能にします。
この値は通常、エージェントの最大の高さに設定されます。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::walkableClimb
@par

Allows the mesh to flow over low lying obstructions such as curbs and 
up/down stairways. The value is usually set to how far up/down an agent can step.
メッシュが縁石や階段の上下などの低位の障害物の上を流れるようにします。
この値は通常、エージェントがステップアップ/ダウンできる距離に設定されます。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::walkableRadius
@par

In general, this is the closest any part of the final mesh should get to an 
obstruction in the source geometry.  It is usually set to the maximum
agent radius.
一般的に、これは最終的なメッシュのどの部分でもソースジオメトリの障害物に到達するのに最も近い場所です。
通常、最大エージェント半径に設定されます。

While a value of zero is legal, it is not recommended and can result in
odd edge case issues.
ゼロの値は有効ですが、これは推奨されておらず、奇妙なエッジケースの問題を引き起こす可能性があります。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::maxEdgeLen
@par

Extra vertices will be inserted as needed to keep contour edges below this
length. A value of zero effectively disables this feature.
必要に応じて追加の頂点が挿入され、輪郭のエッジがこの長さを下回ります。ゼロの値は、この機能を事実上無効にします。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::maxSimplificationError
@par

The effect of this parameter only applies to the xz-plane.
このパラメーターの効果は、xz平面にのみ適用されます。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::minRegionArea
@par

Any regions that are smaller than this area will be marked as unwalkable.
This is useful in removing useless regions that can sometimes form on 
geometry such as table tops, box tops, etc.
このエリアよりも小さい領域は歩行不可としてマークされます。
これは、テーブルトップ、ボックストップなどのジオメトリ上に形成される可能性がある不要な領域を削除するのに役立ちます。

-----------------------------------------------------------------------------------------------------------------------

@var rcConfig::maxVertsPerPoly
@par

If the mesh data is to be used to construct a Detour navigation mesh, then the upper limit
is limited to <= #DT_VERTS_PER_POLYGON.
メッシュデータを使用して迂回ナビゲーションメッシュを作成する場合、上限は<= #DT_VERTS_PER_POLYGONに制限されます。

-----------------------------------------------------------------------------------------------------------------------

@struct rcHeightfield
@par

The grid of a heightfield is layed out on the xz-plane based on the
value of #cs.  Spans exist within the grid columns with the span
min/max values at increments of #ch from the base of the grid.  The smallest 
possible span size is <tt>(#cs width) * (#cs depth) * (#ch height)</tt>. (Which is a single voxel.)
ハイトフィールドのグリッドは、＃csの値に基づいてxz平面に配置されます。
スパンはグリッドの列内に存在し、スパンの最小値/最大値はグリッドのベースから#chの増分で存在します。
可能な最小のスパンサイズは（#cs幅）*（#cs深さ）*（#ch高さ）です。 （これは単一のボクセルです。）

The standard process for buidling a heightfield is to allocate it using
#rcAllocHeightfield, initialize it using #rcCreateHeightfield, then
add spans using the various helper functions such as #rcRasterizeTriangle.
ハイトフィールドを構築するための標準的なプロセスは、rcAllocHeightfieldを使用して割り当て、rcCreateHeightfieldを使用して初期化してから、rcRasterizeTriangleなどのさまざまなヘルパー関数を使用してスパンを追加することです。

Building a heightfield is one of the first steps in creating a polygon mesh
from source geometry.  After it is populated, it is used to build a 
rcCompactHeightfield.
ハイトフィールドの構築は、ソースジオメトリからポリゴンメッシュを作成する最初のステップの1つです。
データが入力された後、rcCompactHeightfieldを構築するために使用されます。

-----------------------------------------------------------------------------------------------------------------------

Example of iterating the spans in a heightfield:
ハイトフィールドのスパンを反復する例：

@code
// Where hf is a reference to an heightfield object.
// hfは、heightfieldオブジェクトへの参照です。

const float* orig = hf.bmin;
const float cs = hf.cs;
const float ch = hf.ch;

const int w = hf.width;
const int h = hf.height;

for (int y = 0; y < h; ++y)
{
    for (int x = 0; x < w; ++x)
    {
        // Deriving the minimum corner of the grid location.
        // グリッド位置の最小コーナーを導出します。
        float fx = orig[0] + x*cs;
        float fz = orig[2] + y*cs;
        
        // The base span in the column. (May be null.)
        // 列のベーススパン。 （nullの場合があります。）
        const rcSpan* s = hf.spans[x + y*w]; 
        
        while (s)
        {
            // Detriving the minium and maximum world position of the span.
            // スパンの最小および最大のワールド位置を取得します。
            float fymin = orig[1]+s->smin*ch;
            float fymax = orig[1] + s->smax*ch;
            
            // Do other things with the span before moving up the column.
            // 列を上に移動する前に、スパンで他のことを行います。
            s = s->next;
        }
    }
}
@endcode

@see rcAllocHeightfield, rcFreeHeightField, rcCreateHeightfield

-----------------------------------------------------------------------------------------------------------------------

@struct rcCompactCell
@par

See the rcCompactHeightfield documentation for an example of how compact cells
are used to iterate the heightfield.
高さフィールドを反復処理するためにコンパクトセルを使用する方法の例については、rcCompactHeightfieldのドキュメントを参照してください。

Useful instances of this type can only by obtained from a #rcCompactHeightfield object.
このタイプの有用なインスタンスは、＃rcCompactHeightfieldオブジェクトからのみ取得できます。

@see rcCompactHeightfield

-----------------------------------------------------------------------------------------------------------------------

@struct rcCompactSpan
@par

The span represents open, unobstructed space within a compact heightfield column.
See the rcCompactHeightfield documentation for an example of iterating spans and searching 
span connections.
スパンは、コンパクトな高さフィールド列内の開いた、遮るもののないスペースを表します。
スパンの反復とスパン接続の検索の例については、rcCompactHeightfieldのドキュメントを参照してください。

Useful instances of this type can only by obtained from a #rcCompactHeightfield object.
このタイプの有用なインスタンスは、rcCompactHeightfieldオブジェクトからのみ取得できます。

@see rcCompactHeightfield

-----------------------------------------------------------------------------------------------------------------------

@struct rcCompactHeightfield
@par

For this type of heightfield, the spans represent the open (unobstructed) 
space above the solid surfaces of a voxel field. It is usually created from 
a #rcHeightfield object.  Data is stored in a compact, efficient manner,  
but the structure is not condusive to adding and removing spans.
このタイプのハイトフィールドの場合、スパンはボクセルフィールドのソリッドサーフェスの上にある開いた（遮るもののない）スペースを表します。 通常はrcHeightfieldオブジェクトから作成されます。 
データはコンパクトで効率的な方法で保存されますが、この構造はスパンの追加や削除を妨げるものではありません。

The standard process for buidling a compact heightfield is to allocate it 
using #rcAllocCompactHeightfield, build it using #rcBuildCompactHeightfield,
then run it through the various helper functions to generate neighbor
and region data.
コンパクトな高さフィールドを構築するための標準的なプロセスは、rcAllocCompactHeightfieldを使用してそれを割り当て、rcBuildCompactHeightfieldを使用してビルドしてから、さまざまなヘルパー関数を実行して隣接データと領域データを生成することです。

Connected neighbor spans form non-overlapping surfaces.  When neighbor 
information is generated, spans will include data that can be used to 
locate axis-neighbors. Axis-neighbors are connected
spans that are offset from the current cell column as follows:
接続された隣接スパンは、重複しないサーフェスを形成します。 
ネイバー情報が生成されると、スパンには、軸ネイバーを見つけるために使用できるデータが含まれます。
Axis-neighborsは、次のように現在のセル列からオフセットされた接続されたスパンです。

<pre>
Direction 0 = (-1, 0)
Direction 1 = (0, 1)
Direction 2 = (1, 0)
Direction 3 = (0, -1)
</pre>

-----------------------------------------------------------------------------------------------------------------------

Example of iterating and inspecting spans, including connected neighbors:
接続されたネイバーを含むスパンの反復と検査の例：

@code
// Where chf is an instance of a rcCompactHeightfield.
// chfはrcCompactHeightfieldのインスタンスです。

const float cs = chf.cs;
const float ch = chf.ch;

for (int y = 0; y < chf.height; ++y)
{
    for (int x = 0; x < chf.width; ++x)
    {
        // Deriving the minimum corner of the grid location.
        // グリッド位置の最小コーナーを導出します。
        const float fx = chf.bmin[0] + x*cs;
        const float fz = chf.bmin[2] + y*cs;

        // Get the cell for the grid location then iterate up the column.
        // グリッド位置のセルを取得し、列を反復します。
        const rcCompactCell& c = chf.cells[x+y*chf.width];
        for (unsigned i = c.index, ni = c.index+c.count; i < ni; ++i)
        {
            const rcCompactSpan& s = chf.spans[i];

            Deriving the minimum (floor) of the span.
            const float fy = chf.bmin[1] + (s.y+1)*ch;

            // Testing the area assignment of the span.
            // スパンのエリア割り当てをテストします。
            if (chf.areas[i] == RC_WALKABLE_AREA)
            { 
                // The span is in the default 'walkable area'.
                // スパンはデフォルトの「歩行可能エリア」にあります。
            }
            else if (chf.areas[i] == RC_NULL_AREA)
            { 
                // The surface is not considered walkable.
                // サーフェスは歩行可能とは見なされません。
                // E.g. It was filtered out during the build processes.
                // 例 ビルドプロセス中に除外されました。
            }
            else
            { 
                // Do something. (Only applicable for custom build build processes.)
                // 何かをします。 （カスタムビルドプロセスにのみ適用されます。）
            }

            // Iterating the connected axis-neighbor spans.
            // 接続された軸の隣接スパンを反復します。
            for (int dir = 0; dir < 4; ++dir)
            {
                if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
                {
                    // There is a neighbor in this direction.
                    // この方向に隣人がいます。
                    const int nx = x + rcGetDirOffsetX(dir);
                    const int ny = y + rcGetDirOffsetY(dir);
                    const int ni = (int)chf.cells[nx+ny*w].index + rcGetCon(s, 0);
                    const rcCompactSpan& ns = chf.spans[ni];
                    
                    // Do something with the neighbor span.
                    // 隣接スパンで何かを行います。
                }
            }
        }
    }
}
@endcode

@see rcAllocCompactHeightfield, rcFreeCompactHeightfield, rcBuildCompactHeightfield

-----------------------------------------------------------------------------------------------------------------------

@struct rcContour
@par

A contour only exists within the context of a #rcContourSet object.
輪郭は、rcContourSetオブジェクトのコンテキスト内にのみ存在します。

While the height of the contour's border may vary, the contour will always 
form a simple polygon when projected onto the xz-plane.
輪郭の境界の高さは変化する可能性がありますが、xz平面に投影すると、輪郭は常に単純なポリゴンを形成します。

Example of converting vertices into world space:
頂点をワールド空間に変換する例：

@code
// Where cset is the rcContourSet object to which the contour belongs.
// csetは、輪郭が属するrcContourSetオブジェクトです。
float worldX = cset.bmin[0] + vertX * cset.cs;
float worldY = cset.bmin[1] + vertY * cset.ch;
float worldZ = cset.bmin[2] + vertZ * cset.cs;
@endcode

@see rcContourSet

-----------------------------------------------------------------------------------------------------------------------

@var rcContour::verts
@par

The simplified contour is a version of the raw contour with all 
'unnecessary' vertices removed. Whether a vertex is 
considered unnecessary depends on the contour build process.
簡略化された輪郭は、すべての「不要な」頂点が削除された生の輪郭のバージョンです。
頂点が不要と見なされるかどうかは、輪郭の作成プロセスによって異なります。

The data format is as follows: (x, y, z, r) * #nverts
データ形式は次のとおりです：（x、y、z、r）* nverts

A contour edge is formed by the current and next vertex. The r-value 
represents region and connection information for the edge. For example:
輪郭エッジは、現在の頂点と次の頂点によって形成されます。 r値は、エッジの領域と接続情報を表します。例えば：

@code
int r = verts[i*4+3];

int regionId = r & RC_CONTOUR_REG_MASK;

if (r & RC_BORDER_VERTEX)
{
    // The edge represents a solid border.
    //エッジは実線の境界を表します。
}

if (r & RC_AREA_BORDER)
{
    // The edge represents a transition between different areas.
    //エッジは、異なる領域間の遷移を表します。
}
@endcode

-----------------------------------------------------------------------------------------------------------------------

@var rcContour::rverts
@par

See #verts for information on element layout.
要素のレイアウトについては、＃vertsを参照してください。

-----------------------------------------------------------------------------------------------------------------------

@struct rcContourSet
@par

All contours within the set share the minimum bounds and cell sizes of the set.
セット内のすべての輪郭は、セットの最小境界とセルサイズを共有します。

The standard process for building a contour set is to allocate it
using #rcAllocContourSet, then initialize it using #rcBuildContours.
等高線セットを作成する標準的なプロセスは、rcAllocContourSetを使用して割り当て、次にrcBuildContoursを使用して初期化することです。

@see rcAllocContourSet, rcFreeContourSet, rcBuildContours

-----------------------------------------------------------------------------------------------------------------------

@struct rcPolyMesh
@par

A mesh of potentially overlapping convex polygons of between three 
and #nvp vertices. The mesh exists within the context of an axis-aligned 
bounding box (AABB) with vertices laid out in an evenly spaced grid, based 
on the values of #cs and #ch.
3つの頂点と#nvp頂点の間の潜在的に重なり合う凸形ポリゴンのメッシュ。
メッシュは、軸整列バウンディングボックス（AABB）のコンテキスト内に存在し、頂点は#csおよび#chの値に基づいて等間隔のグリッドに配置されます。

The standard process for building a contour set is to allocate it using
#rcAllocPolyMesh, the initialize it using #rcBuildPolyMesh
等高線セットを構築する標準的なプロセスは、rcAllocPolyMeshを使用して割り当て、rcBuildPolyMeshを使用して初期化することです。

Example of iterating the polygons:
ポリゴンの反復の例：

@code
// Where mesh is a reference to a rcPolyMesh object.
// meshはrcPolyMeshオブジェクトへの参照です。

const int nvp = mesh.nvp;
const float cs = mesh.cs;
const float ch = mesh.ch;
const float* orig = mesh.bmin;

for (int i = 0; i < mesh.npolys; ++i)
{
   const unsigned short* p = &mesh.polys[i*nvp*2];
   
    // Iterate the vertices. 
    // 頂点を反復します。
   unsigned short vi[3];  // The vertex indices. 頂点インデックス。
   
   for (int j = 0; j < nvp; ++j)
   {
      if (p[j] == RC_MESH_NULL_IDX) 
            break; // End of vertices. 頂点の終わり。

        if (p[j + nvp] == RC_MESH_NULL_IDX)
        {
            // The edge beginning with this vertex is a solid border.
            // この頂点で始まるエッジは実線の境界です。
        }
        else
        {
            // The edge beginning with this vertex connects to polygon p[j + nvp].
            // この頂点で始まるエッジは、ポリゴンp [j + nvp]に接続します。
        }
        
        // Convert to world space.
        // ワールドスペースに変換します。
       const unsigned short* v = &mesh.verts[p[j]*3];
      const float x = orig[0] + v[0]*cs;
      const float y = orig[1] + v[1]*ch;
      const float z = orig[2] + v[2]*cs;
      
      // Do something with the vertices.
      // 頂点で何かを行います。
   }
}
@endcode

@see rcAllocPolyMesh, rcFreePolyMesh, rcBuildPolyMesh

-----------------------------------------------------------------------------------------------------------------------

@var rcPolyMesh::verts
@par

The values of #bmin ,#cs, and #ch are used to convert vertex coordinates
to world space as follows:
#bmin、＃cs、および#chの値は、次のように頂点座標をワールド空間に変換するために使用されます。

@code
float worldX = bmin[0] + verts[i*3+0] * cs
float worldY = bmin[1] + verts[i*3+1] * ch
float worldZ = bmin[2] + verts[i*3+2] * cs
@endcode

-----------------------------------------------------------------------------------------------------------------------

@var rcPolyMesh::polys
@par

Each entry is <tt>2 * #nvp</tt> in length. The first half of the entry 
contains the indices of the polygon. The first instance of #RC_MESH_NULL_IDX
indicates the end of the indices for the entry. The second half contains 
indices to neighbor polygons. A value of #RC_MESH_NULL_IDX indicates no 
connection for the associated edge. (I.e. The edge is a solid border.)
各エントリの長さは2 * #nvpです。エントリの前半には、ポリゴンのインデックスが含まれています。
RC_MESH_NULL_IDXの最初のインスタンスは、エントリのインデックスの終わりを示します。
後半には、隣接するポリゴンへのインデックスが含まれています。
RC_MESH_NULL_IDXの値は、関連するエッジに接続がないことを示します。 （つまり、エッジは実線の境界です）。

For example:
<pre>
nvp = 6
For the entry: (1, 3, 4, 8, RC_MESH_NULL_IDX, RC_MESH_NULL_IDX, 
                18, RC_MESH_NULL_IDX , 21, RC_MESH_NULL_IDX, RC_MESH_NULL_IDX, RC_MESH_NULL_IDX)

(1, 3, 4, 8) defines a polygon with 4 vertices.
Edge 1->3 is shared with polygon 18.
Edge 4->8 is shared with polygon 21.
Edges 3->4 and 4->8 are border edges not shared with any other polygon.
（1、3、4、8）は、4つの頂点を持つポリゴンを定義します。
エッジ1-> 3はポリゴン18と共有されます。
エッジ4-> 8はポリゴン21と共有されます。
エッジ3-> 4および4-> 8は、他のポリゴンと共有されていない境界エッジです。

-----------------------------------------------------------------------------------------------------------------------

@var rcPolyMesh::areas
@par

The standard build process assigns the value of #RC_WALKABLE_AREA to all walkable polygons.
This value can then be changed to meet user requirements.
標準のビルドプロセスでは、RC_WALKABLE_AREAの値をすべてのウォーク可能なポリゴンに割り当てます。
この値は、ユーザーの要件に合わせて変更できます。

-----------------------------------------------------------------------------------------------------------------------

@struct rcPolyMeshDetail
@par

The detail mesh is made up of triangle sub-meshes that provide extra 
height detail for each polygon in its assoicated polygon mesh.
詳細メッシュは、関連するポリゴンメッシュ内の各ポリゴンに追加の高さ詳細を提供する三角形のサブメッシュで構成されています。
The standard process for building a detail mesh is to allocate it 
using #rcAllocPolyMeshDetail, then build it using #rcBuildPolyMeshDetail.
詳細メッシュを作成するための標準的なプロセスは、rcAllocPolyMeshDetailを使用してメッシュを割り当て、次にrcBuildPolyMeshDetailを使用して作成することです。

See the individual field definitions for details realted to the structure
the mesh.
メッシュの構造に関する詳細については、個々のフィールドの定義を参照してください。

@see rcAllocPolyMeshDetail, rcFreePolyMeshDetail, rcBuildPolyMeshDetail, rcPolyMesh

-----------------------------------------------------------------------------------------------------------------------

@var rcPolyMeshDetail::meshes
@par

[(baseVertIndex, vertCount, baseTriIndex, triCount) * #nmeshes]

Maximum number of vertices per sub-mesh: 127<br/>
Maximum number of triangles per sub-mesh: 255
サブメッシュあたりの頂点の最大数：127
サブメッシュあたりの三角形の最大数：255

The sub-meshes are stored in the same order as the polygons from the
rcPolyMesh they represent.  E.g. rcPolyMeshDetail sub-mesh 5 is associated
with #rcPolyMesh polygon 5.
サブメッシュは、それらが表すrcPolyMeshからのポリゴンと同じ順序で保存されます。 例えば。 rcPolyMeshDetailサブメッシュ5は#rcPolyMeshポリゴン5に関連付けられています。

Example of iterating the triangles in a sub-mesh.
サブメッシュで三角形を反復する例。

@code

// Where dmesh is a reference to a rcPolyMeshDetail object.
// ここで、dmeshはrcPolyMeshDetailオブジェクトへの参照です。
// Iterate the sub-meshes. (One for each source polygon.)
// サブメッシュを反復します。 （ソースポリゴンごとに1つ。）

for (int i = 0; i < dmesh.nmeshes; ++i)
{
	const unsigned int* meshDef = &dmesh.meshes[i*4];
	const unsigned int baseVerts = meshDef[0];
	const unsigned int baseTri = meshDef[2];
	const int ntris = (int)meshDef[3];	
	
	const float* verts = &dmesh.verts[baseVerts*3];
	const unsigned char* tris = &dmesh.tris[baseTri*4];

    // Iterate the sub-mesh's triangles.
    // サブメッシュの三角形を反復します。
	for (int j = 0; j < ntris; ++j)
	{
		const float x = verts[tris[j*4+0]*3];
		const float y = verts[tris[j*4+1]*3];
		const float z = verts[tris[j*4+2]*3];
		// Do something with the vertex.
		// 頂点で何かを行います。
	}
}
@endcode

-----------------------------------------------------------------------------------------------------------------------

@var rcPolyMeshDetail::verts
@par

[(x, y, z) * #nverts] 

The vertices are grouped by sub-mesh and will contain duplicates since 
each sub-mesh is independently defined.
頂点はサブメッシュごとにグループ化され、各サブメッシュが個別に定義されているため、重複が含まれます。

The first group of vertices for each sub-mesh are in the same order as 
the vertices for the sub-mesh's associated PolyMesh polygon. These 
vertices are followed by any additional detail vertices. So it the 
associated polygon has 5 vertices, the sub-mesh will have a minimum 
of 5 vertices and the first 5 vertices will be equivalent to the 5 
polygon vertices.
各サブメッシュの最初の頂点グループは、サブメッシュに関連付けられたポリメッシュポリゴンの頂点と同じ順序です。
これらの頂点の後に、追加の詳細頂点が続きます。
したがって、関連付けられたポリゴンには5つの頂点があり、サブメッシュには最低5つの頂点があり、最初の5つの頂点は5つのポリゴンの頂点に相当します。

-----------------------------------------------------------------------------------------------------------------------

@var rcPolyMeshDetail::tris
@par

[(vertIndexA, vertIndexB, vertIndexC, flags) * #ntris] 

The triangles are grouped by sub-mesh.
三角形はサブメッシュごとにグループ化されています。

<b>Vertex Indices</b>

The vertex indices in the triangle array are local to the sub-mesh, not global. 
To translate into an global index in the vertices array, the values must be 
offset by the sub-mesh's base vertex index.
三角形配列の頂点インデックスは、グローバルではなく、サブメッシュに対してローカルです。
頂点配列のグローバルインデックスに変換するには、値をサブメッシュのベース頂点インデックスでオフセットする必要があります。
Example: If the baseVertexIndex for the sub-mesh is 5 and the triangle entry 
is (4, 8, 7, 0), then the actual indices for the vertices are (4 + 5, 8 + 5, 7 + 5).
例：サブメッシュのbaseVertexIndexが5で、三角形のエントリが（4、8、7、0）の場合、頂点の実際のインデックスは（4 + 5、8 + 5、7 + 5）です。

@b Flags

The flags entry indicates which edges are internal and which are external to 
the sub-mesh. Internal edges connect to other triangles within the same sub-mesh. 
External edges represent portals to other sub-meshes or the null region.
フラグエントリは、どのエッジがサブメッシュの内部で、どのエッジが外部であるかを示します。内部エッジは、同じサブメッシュ内の他の三角形に接続します。
外部エッジは、他のサブメッシュまたはヌル領域へのポータルを表します。

Each flag is stored in a 2-bit position. Where position 0 is the lowest 2-bits 
and position 4 is the highest 2-bits:
各フラグは2ビットの位置に格納されます。位置0は最下位の2ビットで、位置4は最上位の2ビットです。

<tt>
Position 0: Edge AB (>> 0)<br/>
Position 1: Edge BC (>> 2)<br/>
Position 2: Edge CA (>> 4)<br/>
Position 4: Unused<br/>
</tt>

Testing can be performed as follows:
テストは次のように実行できます。

@code
if (((flags >> 2) & 0x3) != 0)
{
    // Edge BC is an external edge.
    // エッジBCは外部エッジです。
}
@endcode

-----------------------------------------------------------------------------------------------------------------------

@fn void rcSetCon(rcCompactSpan &s, int dir, int i)
@par

This function is used by the build process. It is rarely of use to end users.
この関数は、ビルドプロセスで使用されます。 エンドユーザーが使用することはめったにありません。

@see #rcCompactHeightfield, #rcCompactSpan

-----------------------------------------------------------------------------------------------------------------------

@fn int rcGetCon(const rcCompactSpan &s, int dir)
@par

Can be used to locate neighbor spans in a compact heightfield. See the 
#rcCompactHeightfield documentation for details on its use.
コンパクトな高さフィールドで隣接するスパンを見つけるために使用できます。 
使用方法の詳細については、rcCompactHeightfieldのドキュメントを参照してください。

@see #rcCompactHeightfield, #rcCompactSpan

-----------------------------------------------------------------------------------------------------------------------

@fn int rcGetDirOffsetX(int dir)
@par

The value of @p dir will be automatically wrapped. So a value of 6 will be interpreted as 2.
dirの値は自動的にラップされます。 したがって、値6は2として解釈されます。

See the #rcCompactHeightfield documentation for usage details.
使用方法の詳細については、rcCompactHeightfieldのドキュメントを参照してください。

-----------------------------------------------------------------------------------------------------------------------

@fn int rcGetDirOffsetY(int dir)
@par

The value of @p dir will be automatically wrapped. So a value of 6 will be interpreted as 2.
dirの値は自動的にラップされます。 したがって、値6は2として解釈されます。

See the #rcCompactHeightfield documentation for usage details.
使用方法の詳細については、rcCompactHeightfieldのドキュメントを参照してください。

*/
